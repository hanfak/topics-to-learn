# Unit testing

- Probably best to be called Isolation Tests
  - opposite of integration tests
- There are many definitions, mainly due to the ambiguous nature of the word unit
  - https://martinfowler.com/bliki/UnitTest.html
  - https://srikanth.sastry.name/defining-unit-tests-two-schools-of-thought/
  - Properties
    - https://www.youtube.com/playlist?list=PLlmVY7qtgT_lkbrk9iZNizp978mVzpBKl
    - Isolated — Unit tests are completely isolated from each other, creating their own test fixtures from scratch each time. (Note that I’m not saying these are the only useful tests, just that if tests aren’t isolated you’re going to have a hard time making the case that they are “unit tests”.)
    - Composable — Follows from isolation.
    - Deterministic — Should be. Code that uses a clock or random numbers should be passed those values by their unit tests.
    - Specific — If a unit test fails, the code of interest should be short.
    - Behavioral — If the behavior changes accidentally, a unit test should fail.
    - Structure-insensitive — This can be a challenge for unit tests. Too much mocking, especially strict mocking, is a structure sensitivity nightmare.
    - Fast — Yep.
    - Writable — Good interface design makes writing unit tests easier. Alternatively, difficult-to-write unit tests are the canary in the bad interface coal mine.
    - Readable — It can be challenge to write readable unit tests, because you are seeing so little context compared to the whole system.
    - Automated — Yep.
    - Predictive — Unit tests passing likely gives little confidence that the whole system is working. Unit tests failing should give great confidence that the whole system is not working.
    - Inspiring — A frequently-run unit test suite gives great confidence the programming is progressing. Sometimes I run my unit tests 2 or 3 times, just because it feels good (and they’re wicked fast).
- there is the case of testing every behaviour a class does
  - but this can lead to highly coupled test code
- APPROACH 1. Unit Testing Use Cases (Uncle Bob)
  - In Clean Architecture (Uncle Bob), the use cases are independent of any out-of-process dependencies, i.e., independent of the database, SMPT, messaging bug, and third-party systems.
  - We can thus unit-test the use cases by mocking out any out-of-process dependencies.
  - the Use Case Unit Tests indirectly cover the Domain (hence there are no Unit Tests targeting the Domain per see).
- APPROACH 2. Integration Testing Use Cases & Unit Testing Domain (Khorikov)
 - In Unit Testing (Vladimir Khorikov), Khorikov distinguishes between managed out-of-process dependencies (e.g., database) versus unmanaged out-of-process dependencies (e.g., SMTP, message bus, third-party systems). Use Cases are implemented through Controllers (Application Service Layer). These controllers have a direct dependency on the database (e.g., reference the ORM), and interfaces are used only for unmanaged dependencies.
 -  we apply a two-level approach for testing the Use Cases. The Use Cases are tested via Integration Tests (unmanaged dependencies are mocked out, but managed dependencies are not mocked out). The Domain is tested via Unit Tests.
- Approach 1 vs Approach 2
  - Which is more optimal? Do we use a hybrid?
  - What about combinatorial explosion?
    - should this be tested at lower/specific level
